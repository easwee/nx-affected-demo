"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizedProjectRoot = exports.readEnvironment = exports.updateProjectFileMap = exports.createProjectFileMap = exports.rootWorkspaceFileData = exports.rootWorkspaceFileNames = exports.workspaceLayout = exports.readNxJson = exports.readPackageJson = exports.defaultFileRead = exports.workspaceFileName = exports.readWorkspaceConfig = exports.readWorkspaceJson = exports.readFileIfExisting = exports.TEN_MEGABYTES = exports.calculateFileChanges = exports.isWholeFileChange = exports.WholeFileChange = void 0;
const workspace_1 = require("@nrwl/tao/src/shared/workspace");
const devkit_1 = require("@nrwl/devkit");
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const path_1 = require("path");
const perf_hooks_1 = require("perf_hooks");
const app_root_1 = require("@nrwl/tao/src/utils/app-root");
const array_1 = require("../utilities/array");
const fileutils_1 = require("../utilities/fileutils");
const json_diff_1 = require("../utilities/json-diff");
const file_hasher_1 = require("./hasher/file-hasher");
const ignore = require('ignore');
class WholeFileChange {
    constructor() {
        this.type = 'WholeFileChange';
    }
}
exports.WholeFileChange = WholeFileChange;
function isWholeFileChange(change) {
    return change.type === 'WholeFileChange';
}
exports.isWholeFileChange = isWholeFileChange;
function calculateFileChanges(files, nxArgs, readFileAtRevision = defaultReadFileAtRevision, ignore = getIgnoredGlobs()) {
    if (ignore) {
        files = files.filter((f) => !ignore.ignores(f));
    }
    return files.map((f) => {
        const ext = (0, path_1.extname)(f);
        const hash = file_hasher_1.defaultFileHasher.hashFile(f);
        return {
            file: f,
            ext,
            hash,
            getChanges: () => {
                if (!nxArgs) {
                    return [new WholeFileChange()];
                }
                if (nxArgs.files && nxArgs.files.includes(f)) {
                    return [new WholeFileChange()];
                }
                switch (ext) {
                    case '.json':
                        const atBase = readFileAtRevision(f, nxArgs.base);
                        const atHead = readFileAtRevision(f, nxArgs.head);
                        try {
                            return (0, json_diff_1.jsonDiff)(JSON.parse(atBase), JSON.parse(atHead));
                        }
                        catch (e) {
                            return [new WholeFileChange()];
                        }
                    default:
                        return [new WholeFileChange()];
                }
            },
        };
    });
}
exports.calculateFileChanges = calculateFileChanges;
exports.TEN_MEGABYTES = 1024 * 10000;
function defaultReadFileAtRevision(file, revision) {
    try {
        const fileFullPath = `${app_root_1.appRootPath}${path_1.sep}${file}`;
        const gitRepositoryPath = (0, child_process_1.execSync)('git rev-parse --show-toplevel')
            .toString()
            .trim();
        const filePathInGitRepository = (0, path_1.relative)(gitRepositoryPath, fileFullPath)
            .split(path_1.sep)
            .join('/');
        return !revision
            ? (0, fs_1.readFileSync)(file, 'utf-8')
            : (0, child_process_1.execSync)(`git show ${revision}:${filePathInGitRepository}`, {
                maxBuffer: exports.TEN_MEGABYTES,
            })
                .toString()
                .trim();
    }
    catch (_a) {
        return '';
    }
}
function getFileData(filePath) {
    const file = (0, path_1.relative)(app_root_1.appRootPath, filePath).split(path_1.sep).join('/');
    return {
        file,
        hash: file_hasher_1.defaultFileHasher.hashFile(filePath),
    };
}
function allFilesInDir(dirName, recurse = true, ignoredGlobs) {
    const relDirName = (0, path_1.relative)(app_root_1.appRootPath, dirName);
    if (relDirName && ignoredGlobs.ignores(relDirName)) {
        return [];
    }
    let res = [];
    try {
        (0, fs_1.readdirSync)(dirName).forEach((c) => {
            const child = (0, path_1.join)(dirName, c);
            if (ignoredGlobs.ignores((0, path_1.relative)(app_root_1.appRootPath, child))) {
                return;
            }
            try {
                const s = (0, fs_1.statSync)(child);
                if (!s.isDirectory()) {
                    // add starting with "apps/myapp/..." or "libs/mylib/..."
                    res.push(getFileData(child));
                }
                else if (s.isDirectory() && recurse) {
                    res = [...res, ...allFilesInDir(child, true, ignoredGlobs)];
                }
            }
            catch (e) { }
        });
    }
    catch (e) { }
    return res;
}
function getIgnoredGlobs() {
    const ig = ignore();
    ig.add(readFileIfExisting(`${app_root_1.appRootPath}/.gitignore`));
    ig.add(readFileIfExisting(`${app_root_1.appRootPath}/.nxignore`));
    return ig;
}
function readFileIfExisting(path) {
    return (0, fs_1.existsSync)(path) ? (0, fs_1.readFileSync)(path, 'utf-8') : '';
}
exports.readFileIfExisting = readFileIfExisting;
function readWorkspaceJson() {
    return readWorkspaceConfig({
        format: 'nx',
        path: app_root_1.appRootPath,
    });
}
exports.readWorkspaceJson = readWorkspaceJson;
function readWorkspaceConfig(opts) {
    const ws = new workspace_1.Workspaces(opts.path || process.cwd());
    const json = ws.readWorkspaceConfiguration();
    if (opts.format === 'angularCli') {
        const formatted = (0, workspace_1.toOldFormatOrNull)(json);
        return formatted !== null && formatted !== void 0 ? formatted : json;
    }
    else {
        return json;
    }
}
exports.readWorkspaceConfig = readWorkspaceConfig;
function workspaceFileName() {
    if ((0, fileutils_1.fileExists)(`${app_root_1.appRootPath}/angular.json`)) {
        return 'angular.json';
    }
    else {
        return 'workspace.json';
    }
}
exports.workspaceFileName = workspaceFileName;
function defaultFileRead(filePath) {
    return (0, fs_1.readFileSync)((0, path_1.join)(app_root_1.appRootPath, filePath), 'utf-8');
}
exports.defaultFileRead = defaultFileRead;
function readPackageJson() {
    return (0, devkit_1.readJsonFile)(`${app_root_1.appRootPath}/package.json`);
}
exports.readPackageJson = readPackageJson;
function readNxJson(path = `${app_root_1.appRootPath}/nx.json`) {
    const config = (0, devkit_1.readJsonFile)(path);
    if (!config.npmScope) {
        throw new Error(`nx.json must define the npmScope property.`);
    }
    const nxJsonExtends = readNxJsonExtends(config);
    if (nxJsonExtends) {
        return Object.assign(Object.assign({}, nxJsonExtends), config);
    }
    else {
        return config;
    }
}
exports.readNxJson = readNxJson;
function readNxJsonExtends(nxJson) {
    if (nxJson.extends) {
        const extendsPath = nxJson.extends;
        try {
            return (0, devkit_1.readJsonFile)(require.resolve(extendsPath));
        }
        catch (e) {
            throw new Error(`Unable to resolve nx.json extends. Error: ${e.message}`);
        }
    }
    else {
        return null;
    }
}
function workspaceLayout() {
    var _a, _b, _c, _d;
    const nxJson = readNxJson();
    return {
        appsDir: (_b = (_a = nxJson.workspaceLayout) === null || _a === void 0 ? void 0 : _a.appsDir) !== null && _b !== void 0 ? _b : 'apps',
        libsDir: (_d = (_c = nxJson.workspaceLayout) === null || _c === void 0 ? void 0 : _c.libsDir) !== null && _d !== void 0 ? _d : 'libs',
    };
}
exports.workspaceLayout = workspaceLayout;
// TODO: Make this list extensible
function rootWorkspaceFileNames() {
    return [`package.json`, workspaceFileName(), `nx.json`, `tsconfig.base.json`];
}
exports.rootWorkspaceFileNames = rootWorkspaceFileNames;
function rootWorkspaceFileData() {
    return rootWorkspaceFileNames().map((f) => getFileData(`${app_root_1.appRootPath}/${f}`));
}
exports.rootWorkspaceFileData = rootWorkspaceFileData;
function readWorkspaceFiles() {
    file_hasher_1.defaultFileHasher.ensureInitialized();
    perf_hooks_1.performance.mark('read workspace files:start');
    if (file_hasher_1.defaultFileHasher.usesGitForHashing) {
        const ignoredGlobs = getIgnoredGlobs();
        const r = Array.from(file_hasher_1.defaultFileHasher.workspaceFiles)
            .filter((f) => !ignoredGlobs.ignores(f))
            .map((f) => getFileData(`${app_root_1.appRootPath}/${f}`));
        perf_hooks_1.performance.mark('read workspace files:end');
        perf_hooks_1.performance.measure('read workspace files', 'read workspace files:start', 'read workspace files:end');
        r.sort((x, y) => x.file.localeCompare(y.file));
        return r;
    }
    else {
        const r = [];
        const ignoredGlobs = getIgnoredGlobs();
        ignoredGlobs.add((0, devkit_1.stripIndents) `
      node_modules
      tmp
      dist
      build    
    `);
        (0, array_1.appendArray)(r, allFilesInDir(app_root_1.appRootPath, true, ignoredGlobs));
        perf_hooks_1.performance.mark('read workspace files:end');
        perf_hooks_1.performance.measure('read workspace files', 'read workspace files:start', 'read workspace files:end');
        r.sort((x, y) => x.file.localeCompare(y.file));
        return r;
    }
}
function sortProjects(workspaceJson) {
    // Sorting here so `apps/client-e2e` comes before `apps/client` and has
    // a chance to match prefix first.
    return Object.keys(workspaceJson.projects).sort((a, b) => {
        const projectA = workspaceJson.projects[a];
        const projectB = workspaceJson.projects[b];
        if (!projectA.root)
            return -1;
        if (!projectB.root)
            return -1;
        return projectA.root.length > projectB.root.length ? -1 : 1;
    });
}
function createProjectFileMap(workspaceJson, allWorkspaceFiles) {
    allWorkspaceFiles = allWorkspaceFiles || readWorkspaceFiles();
    const projectFileMap = {};
    const sortedProjects = sortProjects(workspaceJson);
    const seen = new Set();
    for (const projectName of sortedProjects) {
        projectFileMap[projectName] = [];
    }
    for (const f of allWorkspaceFiles) {
        if (seen.has(f.file))
            continue;
        seen.add(f.file);
        for (const projectName of sortedProjects) {
            const p = workspaceJson.projects[projectName];
            if (f.file.startsWith(p.root || p.sourceRoot)) {
                projectFileMap[projectName].push(f);
                break;
            }
        }
    }
    return { projectFileMap, allWorkspaceFiles };
}
exports.createProjectFileMap = createProjectFileMap;
function updateProjectFileMap(workspaceJson, projectFileMap, allWorkspaceFiles, updatedFiles, deletedFiles) {
    const ignore = getIgnoredGlobs();
    const sortedProjects = sortProjects(workspaceJson);
    for (let projectName of sortedProjects) {
        if (!projectFileMap[projectName]) {
            projectFileMap[projectName] = [];
        }
    }
    for (const f of updatedFiles.keys()) {
        if (ignore.ignores(f))
            continue;
        for (const projectName of sortedProjects) {
            const p = workspaceJson.projects[projectName];
            if (f.startsWith(p.root || p.sourceRoot)) {
                const fileData = projectFileMap[projectName].find((t) => t.file === f);
                if (fileData) {
                    fileData.hash = updatedFiles.get(f);
                }
                else {
                    projectFileMap[projectName].push({
                        file: f,
                        hash: updatedFiles.get(f),
                    });
                }
                break;
            }
        }
        const fileData = allWorkspaceFiles.find((t) => t.file === f);
        if (fileData) {
            fileData.hash = updatedFiles.get(f);
        }
        else {
            allWorkspaceFiles.push({
                file: f,
                hash: updatedFiles.get(f),
            });
        }
    }
    for (const f of deletedFiles) {
        if (ignore.ignores(f))
            continue;
        for (const projectName of sortedProjects) {
            const p = workspaceJson.projects[projectName];
            if (f.startsWith(p.root || p.sourceRoot)) {
                const index = projectFileMap[projectName].findIndex((t) => t.file === f);
                if (index > -1) {
                    projectFileMap[projectName].splice(index, 1);
                }
                break;
            }
        }
        const index = allWorkspaceFiles.findIndex((t) => t.file === f);
        if (index > -1) {
            allWorkspaceFiles.splice(index, 1);
        }
    }
    return { projectFileMap, allWorkspaceFiles };
}
exports.updateProjectFileMap = updateProjectFileMap;
function readEnvironment(target, projects) {
    const nxJson = readNxJson();
    const workspaceJson = readWorkspaceJson();
    return { nxJson, workspaceJson, workspaceResults: null };
}
exports.readEnvironment = readEnvironment;
function normalizedProjectRoot(p) {
    if (p.data && p.data.root) {
        const path = p.data.root.split('/').filter((v) => !!v);
        if (path.length === 1) {
            return path[0];
        }
        // Remove the first part of the path, usually 'libs'
        return path.slice(1).join('/');
    }
    else {
        return '';
    }
}
exports.normalizedProjectRoot = normalizedProjectRoot;
//# sourceMappingURL=file-utils.js.map